cimport cython
from libc.string cimport memcpy
from ... utils.slicing cimport predictSliceLength

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long allocate = -1):
        self.base = BASELISTTYPE(length * AMOUNT, allocate * AMOUNT)

    def __dealloc__(self):
        pass


    # Special Methods for Python
    ###############################################

    def __len__(self):
        return len(self.base) / AMOUNT

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        else:
            return self.getValuesInSlice(key)

    def __setitem__(self, key, values):
        raise NotImplemented()

    def __delitem__(self, key):
        raise NotImplemented()

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        return self.repeated(amount = amount)

    def __iadd__(self, LISTNAME other):
        self.base += other.base
        return self

    def __contains__(self, value):
        raise NotImplemented()

    def __richcmp__(x, y, int operation):
        raise NotImplemented()

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        return getElementFromLISTNAME(self, index)

    cdef tryCorrectIndex(self, long index):
        if index < 0:
            index += self.base.length / AMOUNT
        if index < 0 or index >= self.base.length / AMOUNT:
            raise IndexError("list assignment index out of range")
        return index


    # Base operations for lists - mimic python list
    ###############################################

    cpdef copy(self):
        newList = LISTNAME()
        newList.base = self.base.copy()
        return newList

    cpdef clear(self):
        self.base.clear()

    cpdef append(self, value):
        appendToLISTNAME(self, value)

    cpdef extend(self, values):
        for value in values:
            self.append(value)

    cpdef index(self, value):
        raise NotImplemented()

    cpdef long count(self, value):
        raise NotImplemented()

    cpdef remove(self, value):
        raise NotImplemented()

    cpdef insert(self, long index, value):
        raise NotImplemented()

    cdef LISTNAME getValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long realStart, realStop, realStep
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        try: start, stop, step = sliceObject.indices(len(self))
        except: raise Exception("Expected slice object. Not:", type(sliceObject))
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        realStart = start * AMOUNT
        realStop = stop * AMOUNT
        realStep = step * AMOUNT

        newIndex = 0
        oldIndex = realStart

        if step == 1:
            memcpy(newList.base.data, self.base.data + realStart, outLength * AMOUNT * sizeof(BASETYPE))
        elif step > 1:
            while oldIndex < realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT
        elif step < 0:
            while oldIndex > realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT

        return newList

    @classmethod
    def join(cls, *sourceLists):
        cdef LISTNAME newList = LISTNAME()
        sources = [(<LISTNAME>source).base for source in sourceLists]
        newList.base = BASELISTTYPE.join(*sources)
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        cdef LISTNAME newList = LISTNAME()
        newList.base = self.base.repeated(
                         length = length * AMOUNT,
                         amount = amount)
        return newList

    def reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(len(self))
            long i, offset
        offset = (len(self) - 1) * AMOUNT
        for i in range(len(self)):
            memcpy(newList.base.data + i * AMOUNT,
                   self.base.data + offset - i * AMOUNT,
                   sizeof(BASETYPE) * AMOUNT)
        return newList

    @classmethod
    def fromValues(cls, values):
        newList = LISTNAME()
        newList.extend(values)
        return newList

    def __repr__(self):
        return "<LISTNAME - {}>".format([self[i] for i in range(len(self))])
