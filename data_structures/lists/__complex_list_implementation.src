cimport cython
from libc.string cimport memcpy
from ... utils.slicing cimport predictSliceLength

@cython.freelist(10)
cdef class LISTNAME:

    def __cinit__(self, long length = 0, long allocate = -1):
        self.base = BASELISTTYPE(length * AMOUNT, allocate * AMOUNT)

    def __dealloc__(self):
        pass

    def __len__(self):
        return len(self.base) / AMOUNT

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        else:
            return self.getValuesInSlice(key)

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        return getElementFromLISTNAME(self, index)

    cdef tryCorrectIndex(self, long index):
        if index < 0:
            index += self.base.length / AMOUNT
        if index < 0 or index >= self.base.length / AMOUNT:
            raise IndexError("list assignment index out of range")
        return index

    cpdef append(self, value):
        appendToLISTNAME(self, value)

    cpdef copy(self):
        newList = LISTNAME()
        newList.base = self.base.copy()
        return newList

    cdef LISTNAME getValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long realStart, realStop, realStep
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        try: start, stop, step = sliceObject.indices(len(self))
        except: raise Exception("Expected slice object. Not:", type(sliceObject))
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        realStart = start * AMOUNT
        realStop = stop * AMOUNT
        realStep = step * AMOUNT

        newIndex = 0
        oldIndex = realStart

        if step == 1:
            memcpy(newList.base.data, self.base.data + realStart, outLength * AMOUNT * sizeof(BASETYPE))
        elif step > 1:
            while oldIndex < realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT
        elif step < 0:
            while oldIndex > realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT

        return newList

    def __repr__(self):
        return "<LISTNAME - {}>".format([self[i] for i in range(len(self))])
