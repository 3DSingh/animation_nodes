cimport cython
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy, memmove, memcmp
from ... utils.slicing cimport predictSliceLength, makeStepPositive, removeValuesInSlice

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long allocate = -1):
        self.base = BASELISTTYPE(length * AMOUNT, allocate * AMOUNT)

    def __dealloc__(self):
        pass


    # Special Methods for Python
    ###############################################

    def __len__(self):
        return self.getLength()

    cdef inline long getLength(self):
        return self.base.length / AMOUNT

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        elif isinstance(key, slice):
            return self.getValuesInSlice(key)
        else:
            raise TypeError("Expected int or slice object")

    def __setitem__(self, key, value):
        if isinstance(key, int):
            self.setValueAtIndex(key, value)
        elif isinstance(key, slice):
            self.setValuesInSlice(key, value)
        else:
            raise TypeError("Expected int or slice object")

    def __delitem__(self, key):
        if isinstance(key, int):
            self.removeValueAtIndex(key)
        elif isinstance(key, slice):
            self.removeValuesInSlice(key)
        else:
            raise TypeError("Expected int or slice object")

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        return self.repeated(amount = amount)

    def __iadd__(self, LISTNAME other):
        self.base += other.base
        return self

    def __iter__(self):
        return LISTNAMEIterator(self)

    def __contains__(self, value):
        if len(value) != AMOUNT: raise TypeError("input has wrong type")
        cdef BASELISTTYPE search = BASELISTTYPE.fromValues(value)
        cdef long i
        cdef int compareResult
        for i in range(self.getLength()):
            compareResult = memcmp(search.data,
                                   self.base.data + i * AMOUNT,
                                   sizeof(BASETYPE) * AMOUNT)
            if compareResult == 0: return True
        return False


    def __richcmp__(x, y, int operation):
        if operation == 2: # '=='
            if type(x) == type(y):
                return (<LISTNAME>x).base == (<LISTNAME>y).base
        raise NotImplemented()


    # Base operations for lists - mimic python list
    ###############################################

    cpdef copy(self):
        newList = LISTNAME()
        newList.base = self.base.copy()
        return newList

    cpdef clear(self):
        self.base.clear()

    cpdef append(self, value):
        if self.base.capacity < self.base.length + AMOUNT:
            self.base.grow(self.base.length + AMOUNT)
        if 0 == elementToArrayOfLISTNAME(value, self.base.data + self.base.length):
            self.base.length += AMOUNT
        else:
            raise TypeError("Cannot append the value to LISTNAME")

    cpdef extend(self, values):
        if isinstance(values, LISTNAME):
            self.base.extend((<LISTNAME>values).base)
        else:
            for value in values:
                self.append(value)

    cpdef index(self, value):
        return self.searchIndex(value)

    cdef searchIndex(self, value):
        cdef BASETYPE search[AMOUNT]
        if 0 != elementToArrayOfLISTNAME(value, search):
            raise TypeError("Value has to be an element of LISTNAME")
        cdef long i
        for i in range(self.getLength()):
            if 0 == memcmp(search,
                           self.base.data + i * AMOUNT,
                           sizeof(BASETYPE) * AMOUNT):
                return i
        raise ValueError("value not in list")

    cpdef count(self, value):
        cdef BASETYPE search[AMOUNT]
        if 0 != elementToArrayOfLISTNAME(value, search):
            raise TypeError("Value has to be an element of LISTNAME")
        cdef long i, counter = 0
        for i in range(self.getLength()):
            if 0 == memcmp(search,
                           self.base.data + i * AMOUNT,
                           sizeof(BASETYPE) * AMOUNT):
                counter += 1
        return counter

    cpdef remove(self, value):
        cdef long index = self.searchIndex(value)
        memmove(self.base.data + AMOUNT * index,
                self.base.data + AMOUNT * (index + 1),
                (self.base.length - index * AMOUNT) * sizeof(BASETYPE))
        self.base.length -= AMOUNT

    cpdef insert(self, long index, value):
        if index >= self.getLength(): index = self.getLength()
        if index < 0: index += self.getLength()
        if index < 0: index = 0

        cdef BASELISTTYPE valueFlattened = BASELISTTYPE(length = AMOUNT)
        if 0 == elementToArrayOfLISTNAME(value, valueFlattened.data):
            self.base.setValuesInSimpleSlice(index * AMOUNT, index * AMOUNT, valueFlattened)
        else:
            raise TypeError("Value has to be an element of LISTNAME")



    # Get/Set/Remove single element
    ################################################

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex_Fast(index)
        if index >= 0: return getElementFromLISTNAME(self, index)
        else: raise IndexError("list assignment index out of range")

    cdef setValueAtIndex(self, long index, value):
        index = self.tryCorrectIndex(index)
        cdef BASETYPE valueArray[AMOUNT]
        if 0 == elementToArrayOfLISTNAME(value, valueArray):
            self.base.overwriteArray(valueArray, AMOUNT, index * AMOUNT)
        else:
            raise TypeError("Value has to be an element of LISTNAME")

    cdef removeValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        memmove(self.base.data + AMOUNT * index,
                self.base.data + AMOUNT * (index + 1),
                (self.base.length - index * AMOUNT) * sizeof(BASETYPE))
        self.base.length -= AMOUNT

    cdef tryCorrectIndex(self, long index):
        index = self.tryCorrectIndex_Fast(index)
        if index >= 0: return index
        raise IndexError("list assignment index out of range")

    cdef long tryCorrectIndex_Fast(self, long index):
        cdef long length = self.getLength()
        if 0 <= index < length: return index
        index += length
        if 0 <= index < length: return index
        return -1


    # Get/Set/Remove elements in slice
    ################################################

    cdef LISTNAME getValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long realStart, realStop, realStep
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        start, stop, step = sliceObject.indices(self.getLength())
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        realStart = start * AMOUNT
        realStop = stop * AMOUNT
        realStep = step * AMOUNT

        newIndex = 0
        oldIndex = realStart

        if step == 1:
            memcpy(newList.base.data, self.base.data + realStart, outLength * AMOUNT * sizeof(BASETYPE))
        elif step > 1:
            while oldIndex < realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT
        elif step < 0:
            while oldIndex > realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT

        return newList

    cdef setValuesInSlice(self, sliceObject, values):
        cdef:
            long start, stop, step
            long sliceLength

        start, stop, step = sliceObject.indices(self.getLength())
        sliceLength = predictSliceLength(start, stop, step)
        if sliceLength != len(values):
            raise ValueError("attempt to assign sequence of size {} to extended slice of size {}"
                             .format(len(values), sliceLength))

        for index, value in zip(range(start, stop, step), values):
            self.setValueAtIndex(index, value)

    cdef removeValuesInSlice(self, sliceObject):
        cdef long start, stop, step
        start, stop, step = sliceObject.indices(len(self))
        cdef long removeAmount = removeValuesInSlice(
                    arrayStart = <char*>self.base.data,
                    arrayLength = self.base.length * sizeof(BASETYPE),
                    elementSize = sizeof(BASETYPE) * AMOUNT,
                    start = start, stop = stop, step = step)
        self.base.length -= removeAmount * AMOUNT

    @classmethod
    def join(cls, *sourceLists):
        cdef LISTNAME newList = LISTNAME()
        sources = [(<LISTNAME>source).base for source in sourceLists]
        newList.base = BASELISTTYPE.join(*sources)
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        cdef LISTNAME newList = LISTNAME()
        newList.base = self.base.repeated(
                         length = length * AMOUNT,
                         amount = amount)
        return newList

    def reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(self.getLength())
            long i, offset
        offset = (self.getLength() - 1) * AMOUNT
        for i in range(self.getLength()):
            memcpy(newList.base.data + i * AMOUNT,
                   self.base.data + offset - i * AMOUNT,
                   sizeof(BASETYPE) * AMOUNT)
        return newList

    @classmethod
    def fromValues(cls, values):
        newList = LISTNAME()
        newList.extend(values)
        return newList

    def __repr__(self):
        return "<LISTNAME {}>".format([self[i] for i in range(self.getLength())])


cdef class LISTNAMEIterator:
    '''
    Implements the 'Iterator Protocol' that is used to allow iteration
    over a custom list object (eg with a for loop).
    An instance of this class is only created in the __iter__ method
    of the corresponding list type.
    https://docs.python.org/3.5/library/stdtypes.html#iterator-types
    '''
    cdef:
        LISTNAME source
        long current

    def __cinit__(self, LISTNAME source):
        self.source = source
        self.current = 0

    def __next__(self):
        if self.current >= self.source.getLength():
            raise StopIteration()
        value = getElementFromLISTNAME(self.source, self.current)
        self.current += 1
        return value
