cimport cython
from libc.string cimport memcpy, memmove, memcmp
from ... utils.slicing cimport predictSliceLength

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long allocate = -1):
        self.base = BASELISTTYPE(length * AMOUNT, allocate * AMOUNT)

    def __dealloc__(self):
        pass


    # Special Methods for Python
    ###############################################

    def __len__(self):
        return len(self.base) / AMOUNT

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        else:
            return self.getValuesInSlice(key)

    def __setitem__(self, key, value):
        if isinstance(key, int):
            self.setValueAtIndex(key, value)
        else:
            self.setValuesInSlice(key, value)

    def __delitem__(self, key):
        if isinstance(key, int):
            self.removeValueAtIndex(key)
        else:
            raise NotImplemented()

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        return self.repeated(amount = amount)

    def __iadd__(self, LISTNAME other):
        self.base += other.base
        return self

    def __contains__(self, value):
        if len(value) != AMOUNT: raise TypeError("input has wrong type")
        cdef BASELISTTYPE search = BASELISTTYPE.fromValues(value)
        cdef long i
        cdef int compareResult
        for i in range(len(self)):
            compareResult = memcmp(search.data,
                                   self.base.data + i * AMOUNT,
                                   sizeof(BASETYPE) * AMOUNT)
            if compareResult == 0: return True
        return False


    def __richcmp__(x, y, int operation):
        raise NotImplemented()


    # Base operations for lists - mimic python list
    ###############################################

    cpdef copy(self):
        newList = LISTNAME()
        newList.base = self.base.copy()
        return newList

    cpdef clear(self):
        self.base.clear()

    cpdef append(self, value):
        cdef BASELISTTYPE valueFlattened = elementToBaseListOfLISTNAME(value)
        self.base.extend(valueFlattened)

    cpdef extend(self, values):
        for value in values:
            self.append(value)

    cpdef index(self, value):
        return self.searchIndex(value)

    cdef searchIndex(self, value):
        if len(value) != AMOUNT: raise TypeError("value has wrong type")
        cdef BASELISTTYPE search = elementToBaseListOfLISTNAME(value)
        cdef long i
        for i in range(len(self)):
            if 0 == memcmp(search.data,
                           self.base.data + i * AMOUNT,
                           sizeof(BASETYPE) * AMOUNT):
                return i
        raise ValueError("value not in list")

    cpdef count(self, value):
        if len(value) != AMOUNT:
            raise TypeError("value has wrong type")
        cdef BASELISTTYPE search = elementToBaseListOfLISTNAME(value)
        cdef long i, counter = 0
        for i in range(len(self)):
            if 0 == memcmp(search.data,
                           self.base.data + i * AMOUNT,
                           sizeof(BASETYPE) * AMOUNT):
                counter += 1
        return counter

    cpdef remove(self, value):
        cdef long index = self.searchIndex(value)
        memmove(self.base.data + AMOUNT * index,
                self.base.data + AMOUNT * (index + 1),
                (self.base.length - index * AMOUNT) * sizeof(BASETYPE))
        self.base.length -= AMOUNT

    cpdef insert(self, long index, value):
        raise NotImplemented()


    # Get/Set/Remove single element
    ################################################

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        return getElementFromLISTNAME(self, index)

    cdef setValueAtIndex(self, long index, value):
        index = self.tryCorrectIndex(index)
        cdef BASELISTTYPE valueFlattened = elementToBaseListOfLISTNAME(value)
        self.base.overwrite(valueFlattened, index * AMOUNT)

    cdef removeValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        memmove(self.base.data + AMOUNT * index,
                self.base.data + AMOUNT * (index + 1),
                (self.base.length - index * AMOUNT) * sizeof(BASETYPE))
        self.base.length -= AMOUNT

    cdef tryCorrectIndex(self, long index):
        if index < 0:
            index += self.base.length / AMOUNT
        if index < 0 or index >= self.base.length / AMOUNT:
            raise IndexError("list assignment index out of range")
        return index


    # Get/Set/Remove elements in slice
    ################################################

    cdef LISTNAME getValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long realStart, realStop, realStep
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        try: start, stop, step = sliceObject.indices(len(self))
        except: raise TypeError("Expected slice object. Not: {}".format(type(sliceObject)))
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        realStart = start * AMOUNT
        realStop = stop * AMOUNT
        realStep = step * AMOUNT

        newIndex = 0
        oldIndex = realStart

        if step == 1:
            memcpy(newList.base.data, self.base.data + realStart, outLength * AMOUNT * sizeof(BASETYPE))
        elif step > 1:
            while oldIndex < realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT
        elif step < 0:
            while oldIndex > realStop:
                memcpy(newList.base.data + newIndex, self.base.data + oldIndex, AMOUNT * sizeof(BASETYPE))
                oldIndex += realStep
                newIndex += AMOUNT

        return newList

    cdef setValuesInSlice(self, sliceObject, values):
        cdef:
            long start, stop, step
            long sliceLength

        try: start, stop, step = sliceObject.indices(len(self))
        except: raise TypeError("Expected slice object. Not: {}".format(type(sliceObject)))
        sliceLength = predictSliceLength(start, stop, step)
        if sliceLength != len(values):
            raise ValueError("attempt to assign sequence of size {} to extended slice of size {}"
                             .format(len(values), sliceLength))

        for index, value in zip(range(start, stop, step), values):
            self.setValueAtIndex(index, value)

    @classmethod
    def join(cls, *sourceLists):
        cdef LISTNAME newList = LISTNAME()
        sources = [(<LISTNAME>source).base for source in sourceLists]
        newList.base = BASELISTTYPE.join(*sources)
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        cdef LISTNAME newList = LISTNAME()
        newList.base = self.base.repeated(
                         length = length * AMOUNT,
                         amount = amount)
        return newList

    def reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(len(self))
            long i, offset
        offset = (len(self) - 1) * AMOUNT
        for i in range(len(self)):
            memcpy(newList.base.data + i * AMOUNT,
                   self.base.data + offset - i * AMOUNT,
                   sizeof(BASETYPE) * AMOUNT)
        return newList

    @classmethod
    def fromValues(cls, values):
        newList = LISTNAME()
        newList.extend(values)
        return newList

    def __repr__(self):
        return "<LISTNAME - {}>".format([self[i] for i in range(len(self))])
