##OUTPUT base_lists.pyx

from libc.stdlib cimport malloc, free, realloc
from libc.string cimport memcpy
from libc.math cimport sin
cimport cython

ctypedef fused list_or_tuple:
    list
    tuple

##INSERT list_iterator.src {'LISTNAME': 'FloatList', 'TYPE' : 'float'}
##INSERT base_list.src {'LISTNAME': 'FloatList', 'TYPE' : 'float'}

##INSERT list_iterator.src {'LISTNAME': 'DoubleList', 'TYPE' : 'double'}
##INSERT base_list.src {'LISTNAME': 'DoubleList', 'TYPE' : 'double'}
    @classmethod
    def fromRange(cls, long amount, double start, double step):
        cdef DoubleList newList = DoubleList(max(0, amount))
        cdef long i
        for i in range(max(0, amount)):
            newList.data[i] = start + i * step
        return newList


##INSERT list_iterator.src {'LISTNAME': 'IntegerList', 'TYPE' : 'long long'}
##INSERT base_list.src {'LISTNAME': 'IntegerList', 'TYPE' : 'long long'}


cpdef DoubleList floatListToDoubleList(FloatList floatList):
    cdef DoubleList newList = DoubleList(floatList.length)
    cdef long i
    for i in range(len(floatList)):
        newList.data[i] = floatList.data[i]
    return newList


'''
Lists have to support the following operations:
    myList.append(baseType)
    myList.extend(baseTypeList)
    myList.fill(baseType)
    list.join(*lists)
    list.fromValues(baseTypeList)
    len(myList)                     # __len__
    myList + otherList              # __add__
    myList += otherList             # __iadd__
    myList * x                      # __mul__
    myList[x]  | myList[x:y:z]      # __getitem__
    myList = x | myList[x:y:z] = x  # __setitem__
    x in myList                     # __contains__
'''
