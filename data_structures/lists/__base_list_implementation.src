cimport cython
from libc.stdlib cimport malloc, free, realloc
from libc.string cimport memcpy, memmove, memcmp
from ... utils.slicing cimport predictSliceLength, makeStepPositive

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long allocate = -1):
        '''
        Initialize a new object with the given length.
        You can also directly allocate more memory from the beginning
        to allow faster appending/extending without memory reallocation.
        '''
        if length < 0:
            raise ValueError("Length has to be >= 0")
        if allocate < length:
            allocate = length
        self.data = <TYPE*>malloc(sizeof(TYPE) * allocate)
        if self.data == NULL:
            raise MemoryError()

        self.length = length
        self.capacity = allocate

    def __dealloc__(self):
        if self.data != NULL:
            free(self.data)

    cdef void grow(self, long minCapacity):
        if minCapacity < self.capacity:
            return

        cdef long newCapacity = minCapacity * 2 + 1
        self.data = <TYPE*>realloc(self.data, sizeof(TYPE) * newCapacity)
        if self.data == NULL:
            self.length = 0
            self.capacity = 0
            raise MemoryError()
        self.capacity = newCapacity

    cdef void shrinkToLength(self):
        cdef long newCapacity = max(1, self.length)
        self.data = <TYPE*>realloc(self.data, sizeof(TYPE) * newCapacity)
        self.capacity = newCapacity




    # Magic Methods for Python
    ###############################################

    def __len__(self):
        return self.length

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        else:
            return self.getValuesInSlice(key)

    def __setitem__(self, key, value):
        if isinstance(key, int):
            self.setValueAtIndex(key, value)
        else:
            self.setValuesInSlice(key, value)

    def __delitem__(self, key):
        if isinstance(key, int):
            self.removeValueAtIndex(key)
        else:
            self.removeValuesInSlice(key)

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        amount = max(amount, 0)
        cdef LISTNAME newList = LISTNAME(self.length * amount)
        cdef long i
        if self.length == 0:
            pass
        elif self.length == 1:
            newList.fill(self.data[0])
        else:
            for i in range(amount):
                newList.overwrite(self, self.length * i)
        return newList

    def __iadd__(self, LISTNAME other):
        self.grow(self.length + other.length)
        self.overwrite(other, index = self.length)
        return self

    def __iter__(self):
        return LISTNAMEIterator(self)

    def __contains__(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return True
        return False

    def __richcmp__(x, y, int operation):
        if operation == 2: # '=='
            if type(x) == type(y):
                return (<LISTNAME>x).equals_SameType(y)
            if len(x) == len(y):
                return all(a == b for a, b in zip(x, y))
            return False
        raise NotImplemented()

    cdef equals_SameType(self, LISTNAME other):
        if self.length != other.length:
            return False
        return memcmp(self.data, other.data, self.length * sizeof(TYPE)) == 0


    # Base Operations for Lists
    ###############################################

    cpdef copy(self):
        newList = LISTNAME(self.length)
        newList.overwrite(self)
        return newList

    cpdef clear(self):
        self.length = 0
        self.shrinkToLength()

    cpdef append(self, TYPE value):
        self.grow(self.length + 1)
        self.data[self.length] = value
        self.length += 1

    cpdef extend(self, values):
        cdef long newLength = self.length + len(values)
        self.grow(newLength)
        cdef long i
        for i, value in enumerate(values, start = self.length):
            self.data[i] = value
        self.length = newLength

    cpdef fill(self, TYPE value):
        cdef long i
        for i in range(self.length):
            self.data[i] = value

    cpdef long index(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return i
        return -1

    cpdef long count(self, TYPE value):
        cdef long i
        cdef long amount = 0
        for i in range(self.length):
            if self.data[i] == value:
                amount += 1
        return amount

    cpdef remove(self, TYPE value):
        cdef long index = self.index(value)
        if index == -1:
            raise ValueError("value not in list")
        else:
            self.removeValueAtIndex(index)

    cpdef insert(self, long index, TYPE value):
        if index >= self.length:
            self.append(value)
        else:
            self.grow(self.length + 1)
            if index < 0: index += self.length
            if index < 0: index = 0
            memmove(self.data + index + 1,
                    self.data + index,
                    sizeof(TYPE) * (self.length - index))
            self.data[index] = value
            self.length += 1

    cpdef overwrite(self, LISTNAME other, long index = 0):
        self.grow(index + other.length)
        memcpy(self.data + index, other.data, other.length * sizeof(TYPE))
        self.length = max(self.length, index + other.length)

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        return self.data[index]

    cdef setValueAtIndex(self, long index, TYPE value):
        index = self.tryCorrectIndex(index)
        self.data[index] = value

    cdef removeValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        memmove(self.data + index, self.data + index + 1, (self.length - index) * sizeof(TYPE))
        self.length -= 1

    cdef removeValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long removeAmount
            long i, stepMinusOne
            TYPE* sliceStart

        start, stop, step = sliceObject.indices(self.length)
        if step < 0:
            start, stop, step = makeStepPositive(start, stop, step)
        removeAmount = predictSliceLength(start, stop, step)
        if removeAmount == 0: return

        sliceStart = self.data + start
        stepMinusOne = step - 1

        if step == 1:
            memmove(sliceStart,
                    self.data + stop,
                    sizeof(TYPE) * (self.length - start - removeAmount))
        elif step > 1:
            # Move values between the steps
            for i in range(removeAmount - 1):
                memmove(sliceStart + i * stepMinusOne,
                        sliceStart + i * step + 1,
                        sizeof(TYPE) * stepMinusOne)

            # Move values behind the last step
            memmove(sliceStart + (removeAmount - 1) * stepMinusOne,
                    sliceStart + (removeAmount - 1) * step + 1,
                    sizeof(TYPE) * (self.length - (start + (removeAmount - 1) * step + 1)))

        self.length -= removeAmount

    cdef tryCorrectIndex(self, long index):
        if index < 0:
            index += self.length
        if index < 0 or index >= self.length:
            raise IndexError("list assignment index out of range")
        return index

    cdef setValuesInSlice(self, sliceObject, values):
        cdef:
            long start, stop, step
            long sliceLength

        start, stop, step = sliceObject.indices(self.length)
        sliceLength = predictSliceLength(start, stop, step)
        if sliceLength != len(values):
            raise ValueError("attempt to assign sequence of size {} to extended slice of size {}"
                             .format(len(values), sliceLength))

        for i, value in zip(range(start, stop, step), values):
            self.data[i] = value



    # Create new lists based on an existing list
    ###############################################

    cpdef LISTNAME reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(self.length)
            long i, offset
        offset = self.length - 1
        for i in range(self.length):
            newList.data[i] = self.data[offset - i]
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        if length < 0 and amount < 0:
            raise ValueError("Specify the 'length' or 'amount' parameter as keyword")
        elif length > 0 and amount > 0:
            raise ValueError("Can only evaluate one parameter of 'length' and 'amount'")

        if amount >= 0:
            length = self.length * amount

        if self.length == 0 and length > 0:
            raise ValueError("Cannot repeat a list with zero elements to something longer")

        cdef LISTNAME newList = LISTNAME(length)
        cdef long i = 0, k = 0
        while(i < length):
            newList.data[i] = self.data[k]
            i += 1
            k += 1
            if k == self.length:
                k = 0
        return newList


    # Utility Functions
    ###############################################

    def getMinValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE minValue = self.data[0]
        for i in range(self.length):
            if self.data[i] < minValue:
                minValue = self.data[i]
        return minValue

    def getMaxValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE maxValue = self.data[0]
        for i in range(self.length):
            if self.data[i] > maxValue:
                maxValue = self.data[i]
        return maxValue

    def getSumOfElements(self):
        cdef TYPE sum = 0
        for i in range(self.length):
            sum += self.data[i]
        return sum

    def getProductOfElements(self):
        cdef TYPE sum = 1
        for i in range(self.length):
            sum *= self.data[i]
        return sum

    def getAverageOfElements(self):
        return <double>self.getSumOfElements() / <double>self.length

    def containsValueLowerThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] < value:
                return True
        return False

    def containsValueGreaterThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] > value:
                return True
        return False

    def getSubTuple(self, long start, long length):
        if 0 <= start < start + length <= self.length:
            return tuple(self.data[i] for i in range(start, start + length))
        raise IndexError("Index out of range")


    # Memory Views
    ###############################################

    cpdef TYPE[:] getMemoryView(self):
        if self.length > 0:
            return <TYPE[:self.length]>self.data
        else:
            # hack to make zero-length memview possible
            return (<TYPE[:1]>self.data)[1:]

    cdef LISTNAME getValuesInSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        start, stop, step = sliceObject.indices(self.length)
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        newIndex = 0
        oldIndex = start
        if step == 1:
            memcpy(newList.data, self.data + start, outLength * sizeof(TYPE))
        elif step > 1:
            while oldIndex < stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1
        elif step < 0:
            while oldIndex > stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1

        return newList


    # Classmethods for List Creation
    ###############################################

    @classmethod
    def join(cls, *sourceLists):
        cdef long newLength = 0
        cdef long offset = 0
        cdef LISTNAME source

        for source in sourceLists:
            newLength += len(source)
        newList = LISTNAME(newLength)
        for source in sourceLists:
            newList.overwrite(source, offset)
            offset += source.length

        return newList

    @classmethod
    def fromValues(cls, list_or_tuple values):
        newList = LISTNAME(len(values))
        cdef long i
        for i, value in enumerate(values):
            newList.data[i] = value
        return newList


    # String Representations
    ###############################################

    def __repr__(self):
        memView = self.getMemoryView()
        if len(memView) < 20:
            return "<LISTNAME {}>".format(list(memView))
        else:
            return "<LISTNAME [{}, ...]>".format(", ".join(str(e) for e in memView[:20]))

    def status(self):
        return "Length: {}, Allocated: {}, Size: {} bytes".format(
            self.length, self.capacity, self.capacity * sizeof(TYPE))


cdef class LISTNAMEIterator:
    '''
    Implements the 'Iterator Protocol' that is used to allow iteration
    over a custom list object (eg with a for loop).
    An instance of this class is only created in the __iter__ method
    of the corresponding list type.
    https://docs.python.org/3.5/library/stdtypes.html#iterator-types
    '''
    cdef:
        LISTNAME source
        long current

    def __cinit__(self, LISTNAME source):
        self.source = source
        self.current = 0

    def __next__(self):
        if self.current >= self.source.length:
            raise StopIteration()
        cdef TYPE currentValue = self.source.data[self.current]
        self.current += 1
        return currentValue
