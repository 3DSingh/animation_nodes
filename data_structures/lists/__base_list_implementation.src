cimport cython
from libc.string cimport memcpy
from libc.stdlib cimport malloc, free, realloc
from ... utils.lists cimport predictRangeLength

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long allocate = -1):
        '''
        Initialize a new object with the given length.
        You can also directly allocate more memory from the beginning
        to allow faster appending/extending without memory reallocation.
        '''
        if length < 0:
            raise Exception("Length has to be >= 0")
        if allocate < length:
            allocate = length
        self.data = <TYPE*>malloc(sizeof(TYPE) * allocate)
        if self.data == NULL:
            raise MemoryError()

        self.length = length
        self.allocated = allocate

    def __dealloc__(self):
        if self.data != NULL:
            free(self.data)

    cdef void _resize(self, long newSize):
        self.data = <TYPE*>realloc(self.data, sizeof(TYPE) * newSize)
        if self.data == NULL:
            self.length = 0
            self.allocated = 0
            raise MemoryError()
        self.allocated = newSize


    # Magic Methods for Python
    ###############################################

    def __len__(self):
        return self.length

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getMemoryView()[key]
        else:
            return self.getSlice(key)

    def __setitem__(self, key, value):
        if isinstance(key, int):
            self.getMemoryView()[key] = value
        else:
            start, stop, step = key.indices(self.length)
            self.getMemoryView()[start:stop:step] = value

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        amount = max(amount, 0)
        cdef LISTNAME newList = LISTNAME(self.length * amount)
        cdef long i
        if self.length == 0:
            pass
        elif self.length == 1:
            newList.fill(self.data[0])
        else:
            for i in range(amount):
                newList.overwrite(self, self.length * i)
        return newList

    def __iadd__(self, LISTNAME other):
        if self.length + other.length > self.allocated:
            self._resize(self.length + other.length)
        self.overwrite(other, index = self.length)
        return self

    def __iter__(self):
        return LISTNAMEIterator(self)

    def __contains__(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return True
        return False


    # Base Operations for Lists
    ###############################################

    cpdef copy(self):
        newList = LISTNAME(self.length)
        newList.overwrite(self)
        return newList

    cpdef append(self, TYPE value):
        if self.length == self.allocated:
            self._resize(<long>(self.allocated * 2) + 1)
        self.data[self.length] = value
        self.length += 1

    cpdef extend(self, values):
        cdef long newLength = self.length + len(values)
        if newLength > self.allocated:
            self._resize(<long>(newLength * 1.5))
        cdef long i
        for i, value in enumerate(values, start = self.length):
            self.data[i] = value
        self.length = newLength

    cpdef fill(self, TYPE value):
        cdef long i
        for i in range(self.length):
            self.data[i] = value

    cpdef long index(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return i
        return -1

    cpdef long count(self, TYPE value):
        cdef long i
        cdef long amount = 0
        for i in range(self.length):
            if self.data[i] == value:
                amount += 1
        return amount

    cpdef overwrite(self, LISTNAME other, long index = 0):
        if index + other.length > self.allocated:
            self._resize(index + other.length)
        memcpy(self.data + index, other.data, other.length * sizeof(TYPE))
        self.length = max(self.length, index + other.length)


    # Create new lists based on an existing list
    ###############################################

    cpdef LISTNAME reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(self.length)
            long i, offset
        offset = self.length - 1
        for i in range(self.length):
            newList.data[i] = self.data[offset - i]
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        if length < 0 and amount < 0:
            raise ValueError("Specify the 'length' or 'amount' parameter as keyword")
        elif length > 0 and amount > 0:
            raise ValueError("Can only evaluate one parameter of 'length' and 'amount'")

        if amount >= 0:
            length = self.length * amount

        if self.length == 0 and length > 0:
            raise ValueError("Cannot repeat a list with zero elements to something longer")

        cdef LISTNAME newList = LISTNAME(length)
        cdef long i = 0, k = 0
        while(i < length):
            newList.data[i] = self.data[k]
            i += 1
            k += 1
            if k == self.length:
                k = 0
        return newList


    # Utility Functions
    ###############################################

    def getMinValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE minValue = self.data[0]
        for i in range(self.length):
            if self.data[i] < minValue:
                minValue = self.data[i]
        return minValue

    def getMaxValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE maxValue = self.data[0]
        for i in range(self.length):
            if self.data[i] > maxValue:
                maxValue = self.data[i]
        return maxValue

    def getSumOfElements(self):
        cdef TYPE sum = 0
        for i in range(self.length):
            sum += self.data[i]
        return sum

    def getProductOfElements(self):
        cdef TYPE sum = 1
        for i in range(self.length):
            sum *= self.data[i]
        return sum

    def getAverageOfElements(self):
        return <double>self.getSumOfElements() / <double>self.length

    def containsValueLowerThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] < value:
                return True
        return False

    def containsValueGreaterThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] > value:
                return True
        return False

    def getSubTuple(self, long start, long length):
        if 0 <= start < start + length <= self.length:
            return tuple(self.data[i] for i in range(start, start + length))
        raise IndexError("Index out of range")


    # Memory Views
    ###############################################

    cpdef TYPE[:] getMemoryView(self):
        if self.length > 0:
            return <TYPE[:self.length]>self.data
        else:
            # hack to make zero-length memview possible
            return (<TYPE[:1]>self.data)[1:]

    cpdef LISTNAME getSlice(self, sliceObject):
        cdef:
            long start, stop, step
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        start, stop, step = sliceObject.indices(self.length)
        outLength = predictRangeLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        newIndex = 0
        oldIndex = start
        if step == 1:
            memcpy(newList.data, self.data + start, outLength * sizeof(TYPE))
        elif step > 0:
            while oldIndex < stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1
        else:
            while oldIndex > stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1

        return newList


    # Classmethods for List Creation
    ###############################################

    @classmethod
    def join(cls, *sourceLists):
        cdef long newLength = 0
        cdef long offset = 0
        cdef LISTNAME source

        for source in sourceLists:
            newLength += len(source)
        newList = LISTNAME(newLength)
        for source in sourceLists:
            newList.overwrite(source, offset)
            offset += source.length

        return newList

    @classmethod
    def fromValues(cls, list_or_tuple values):
        newList = LISTNAME(len(values))
        cdef long i
        for i, value in enumerate(values):
            newList.data[i] = value
        return newList


    # String Representations
    ###############################################

    def __repr__(self):
        memView = self.getMemoryView()
        if len(memView) < 20:
            return "<LISTNAME {}>".format(list(memView))
        else:
            return "<LISTNAME [{}, ...]>".format(", ".join(str(e) for e in memView[:20]))

    def status(self):
        return "Length: {}, Allocated: {}, Size: {} bytes".format(
            self.length, self.allocated, self.allocated * sizeof(TYPE))


cdef class LISTNAMEIterator:
    '''
    Implements the 'Iterator Protocol' that is used to allow iteration
    over a custom list object (eg with a for loop).
    An instance of this class is only created in the __iter__ method
    of the corresponding list type.
    https://docs.python.org/3.5/library/stdtypes.html#iterator-types
    '''
    cdef:
        LISTNAME source
        long current

    def __cinit__(self, LISTNAME source):
        self.source = source
        self.current = 0

    def __next__(self):
        if self.current >= self.source.length:
            raise StopIteration()
        cdef TYPE currentValue = self.source.data[self.current]
        self.current += 1
        return currentValue
