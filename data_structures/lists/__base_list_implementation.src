cimport cython
from types import GeneratorType
from libc.stdlib cimport malloc, free, realloc
from libc.string cimport memcpy, memmove, memcmp
from ... algorithms.lists.convert import toLISTNAME
from . utils cimport predictSliceLength, makeStepPositive, removeValuesInSlice

@cython.freelist(10)
cdef class LISTNAME:

    # Initialization and Memory Management
    ###############################################

    def __cinit__(self, long length = 0, long capacity = -1):
        '''
        Initialize a new object with the given length.
        You can also directly allocate more memory from the beginning
        to allow faster appending/extending without memory reallocation.
        '''
        if length < 0:
            raise ValueError("Length has to be >= 0")
        if capacity < length:
            capacity = length
        self.data = <TYPE*>malloc(sizeof(TYPE) * capacity)
        if self.data == NULL:
            raise MemoryError()

        self.length = length
        self.capacity = capacity

    def __dealloc__(self):
        if self.data != NULL:
            free(self.data)

    cdef grow(self, long minCapacity):
        if minCapacity < self.capacity:
            return

        cdef long newCapacity = minCapacity * 2 + 1
        self.data = <TYPE*>realloc(self.data, sizeof(TYPE) * newCapacity)
        if self.data == NULL:
            self.length = 0
            self.capacity = 0
            raise MemoryError()
        self.capacity = newCapacity

    cdef void shrinkToLength(self):
        cdef long newCapacity = max(1, self.length)
        self.data = <TYPE*>realloc(self.data, sizeof(TYPE) * newCapacity)
        self.capacity = newCapacity


    # Special Methods for Python
    ###############################################

    def __len__(self):
        return self.length

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.getValueAtIndex(key)
        elif isinstance(key, slice):
            return self.getValuesInSlice(key)
        else:
            raise TypeError("Expected int or slice object")

    def __setitem__(self, key, value):
        if isinstance(key, int):
            self.setValueAtIndex(key, value)
        elif isinstance(key, slice):
            self.setValuesInSlice(key, value)
        else:
            raise TypeError("Expected int or slice object")

    def __delitem__(self, key):
        if isinstance(key, int):
            self.removeValueAtIndex(key)
        elif isinstance(key, slice):
            self.removeValuesInSlice(key)
        else:
            raise TypeError("Expected int or slice object")

    def __add__(LISTNAME a, LISTNAME b):
        return LISTNAME.join(a, b)

    def __mul__(LISTNAME self, long amount):
        return self.repeated(amount = amount)

    def __iadd__(self, LISTNAME other):
        self.grow(self.length + other.length)
        self.overwrite(other, index = self.length)
        return self

    def __iter__(self):
        return LISTNAMEIterator(self)

    def __contains__(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return True
        return False

    def __richcmp__(x, y, int operation):
        if operation == 2: # '=='
            if type(x) == type(y):
                return (<LISTNAME>x).equals_SameType(y)
            if len(x) == len(y):
                return all(a == b for a, b in zip(x, y))
            return False
        raise NotImplemented()

    cdef equals_SameType(self, LISTNAME other):
        if self.length != other.length:
            return False
        return memcmp(self.data, other.data, self.length * sizeof(TYPE)) == 0


    # Base operations for lists - mimic python list
    ###############################################

    cpdef copy(self):
        newList = LISTNAME(self.length)
        newList.overwrite(self)
        return newList

    cpdef clear(self):
        self.length = 0
        self.shrinkToLength()

    cpdef fill(self, TYPE value):
        cdef long i
        for i in range(self.length):
            self.data[i] = value

    cpdef append(self, TYPE value):
        if self.length >= self.capacity:
            self.grow(self.length + 1)
        self.data[self.length] = value
        self.length += 1

    cpdef extend(self, values):
        cdef long newLength, i
        if type(values) == LISTNAME:
            self.overwrite(values, self.length)
        elif isinstance(values, list):
            self.extendList(values)
        elif isinstance(values, tuple):
            self.extendTuple(values)
        elif hasattr(values, "__len__"):
            newLength = self.length + len(values)
            self.grow(newLength)
            for i, value in enumerate(values, start = self.length):
                self.data[i] = value
            self.length = newLength
        elif isinstance(values, GeneratorType):
            for value in values:
                self.append(value)
        else:
            raise TypeError("invalid input")

    cdef extendList(self, list values):
        cdef long newLength, i
        newLength = self.length + len(values)
        self.grow(newLength)
        for i in range(len(values)):
            self.data[self.length + i] = values[i]
        self.length = newLength

    cdef extendTuple(self, tuple values):
        cdef long newLength, i
        newLength = self.length + len(values)
        self.grow(newLength)
        for i in range(len(values)):
            self.data[self.length + i] = values[i]
        self.length = newLength

    cpdef index(self, TYPE value):
        cdef long index = self.searchIndex(value)
        if index >= 0: return index
        raise ValueError("value not in list")

    cdef long searchIndex(self, TYPE value):
        cdef long i
        for i in range(self.length):
            if self.data[i] == value:
                return i
        return -1

    cpdef long count(self, TYPE value):
        cdef long i
        cdef long amount = 0
        for i in range(self.length):
            if self.data[i] == value:
                amount += 1
        return amount

    cpdef remove(self, TYPE value):
        cdef long index = self.searchIndex(value)
        if index == -1:
            raise ValueError("value not in list")
        else:
            self.removeValueAtIndex(index)

    cpdef insert(self, long index, TYPE value):
        if index >= self.length:
            self.append(value)
        else:
            self.grow(self.length + 1)
            if index < 0: index += self.length
            if index < 0: index = 0
            memmove(self.data + index + 1,
                    self.data + index,
                    sizeof(TYPE) * (self.length - index))
            self.data[index] = value
            self.length += 1



    # Get/Set/Remove single element
    ################################################

    cdef getValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        return self.data[index]

    cdef setValueAtIndex(self, long index, TYPE value):
        index = self.tryCorrectIndex(index)
        self.data[index] = value

    cdef removeValueAtIndex(self, long index):
        index = self.tryCorrectIndex(index)
        memmove(self.data + index,
                self.data + index + 1,
                (self.length - index) * sizeof(TYPE))
        self.length -= 1


    # Get/Set/Remove elements in slice
    ################################################

    cdef LISTNAME getValuesInSlice(self, slice sliceObject):
        cdef:
            long start, stop, step
            long outLength
            long newIndex, oldIndex
            LISTNAME newList

        start, stop, step = sliceObject.indices(len(self))
        outLength = predictSliceLength(start, stop, step)
        newList = LISTNAME(length = outLength)

        newIndex = 0
        oldIndex = start
        if step == 1:
            memcpy(newList.data, self.data + start, outLength * sizeof(TYPE))
        elif step > 1:
            while oldIndex < stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1
        elif step < 0:
            while oldIndex > stop:
                newList.data[newIndex] = self.data[oldIndex]
                oldIndex += step
                newIndex += 1

        return newList

    cdef setValuesInSlice(self, slice sliceObject, values):
        cdef long start, stop, step
        start, stop, step = sliceObject.indices(len(self))

        if step == 1:
            self.setValuesInSimpleSlice(start, stop, values)
        else:
            self.setValuesInExtendedSlice(start, stop, step, values)

    cdef setValuesInSimpleSlice(self, long start, long stop, values):
        cdef:
            long replacementLength = len(values)
            long sliceLength = predictSliceLength(start, stop, 1)

        if replacementLength > sliceLength:
            self.grow(self.length + (replacementLength - sliceLength))
        if replacementLength != sliceLength:
            memmove(self.data + start + replacementLength,
                    self.data + stop,
                    sizeof(TYPE) * (self.length - stop))
            self.length += replacementLength - sliceLength

        if isinstance(values, LISTNAME):
            self.overwrite(values, start)
        else:
            for i in range(replacementLength):
                self.data[start + i] = values[i]

    cdef setValuesInExtendedSlice(self, long start, long stop, long step, values):
        cdef long sliceLength = predictSliceLength(start, stop, step)
        if sliceLength != len(values):
            raise ValueError("attempt to assign sequence of size {} to extended slice of size {}"
                             .format(len(values), sliceLength))

        # TODO: Speedup for specific list types + use while loop
        # range does not efficiently work with a variable step
        for i, value in zip(range(start, stop, step), values):
            self.data[i] = value

    cdef removeValuesInSlice(self, slice sliceObject):
        cdef long start, stop, step
        start, stop, step = sliceObject.indices(len(self))
        cdef long removeAmount = removeValuesInSlice(
                    arrayStart = <char*>self.data,
                    arrayLength = self.length * sizeof(TYPE),
                    elementSize = sizeof(TYPE),
                    start = start, stop = stop, step = step)
        self.length -= removeAmount


    # Create new lists based on an existing list
    ###############################################

    cpdef LISTNAME reversed(self):
        cdef:
            LISTNAME newList = LISTNAME(self.length)
            long i, offset
        offset = self.length - 1
        for i in range(self.length):
            newList.data[i] = self.data[offset - i]
        return newList

    def repeated(self, *, long length = -1, long amount = -1):
        if length < 0 and amount < 0:
            raise ValueError("Specify the 'length' or 'amount' parameter as keyword")
        elif length > 0 and amount > 0:
            raise ValueError("Can only evaluate one parameter of 'length' and 'amount'")

        if amount >= 0:
            length = self.length * amount

        if self.length == 0 and length > 0:
            raise ValueError("Cannot repeat a list with zero elements to something longer")

        cdef:
            LISTNAME newList = LISTNAME(length)
            long copyAmount = length // self.length
            long i

        # Full copy as often as possible
        for i in range(copyAmount):
            memcpy(newList.data + i * self.length,
                   self.data,
                   sizeof(TYPE) * self.length)
        # Partial copy at the end
        memcpy(newList.data + self.length * copyAmount,
               self.data,
               sizeof(TYPE) * (length % self.length))
        return newList


    # Low level utilities
    ###############################################

    cdef tryCorrectIndex(self, long index):
        if index < 0:
            index += self.length
        if index < 0 or index >= self.length:
            raise IndexError("list index out of range")
        return index

    cdef overwrite(self, LISTNAME other, long index = 0):
        if self.capacity <= index + other.length:
            self.grow(index + other.length)
        memcpy(self.data + index, other.data, other.length * sizeof(TYPE))
        self.length = max(self.length, index + other.length)

    cdef overwriteArray(self, TYPE* array, long arrayLength, long index):
        if self.capacity <= index + arrayLength:
            self.grow(index + arrayLength)
        memcpy(self.data + index, array, arrayLength * sizeof(TYPE))
        self.length = max(self.length, index + arrayLength)


    # High level utilities
    ###############################################

    def getMinValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE minValue = self.data[0]
        for i in range(self.length):
            if self.data[i] < minValue:
                minValue = self.data[i]
        return minValue

    def getMaxValue(self):
        if self.length == 0:
            raise ValueError("Cannot find a min value in a list with zero elements")

        cdef TYPE maxValue = self.data[0]
        for i in range(self.length):
            if self.data[i] > maxValue:
                maxValue = self.data[i]
        return maxValue

    def getSumOfElements(self):
        cdef TYPE sum = 0
        for i in range(self.length):
            sum += self.data[i]
        return sum

    def getProductOfElements(self):
        cdef TYPE sum = 1
        for i in range(self.length):
            sum *= self.data[i]
        return sum

    def getAverageOfElements(self):
        return <double>self.getSumOfElements() / <double>self.length

    def containsValueLowerThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] < value:
                return True
        return False

    def containsValueGreaterThan(self, TYPE value):
        for i in range(self.length):
            if self.data[i] > value:
                return True
        return False


    # Memory Views
    ###############################################

    cpdef TYPE[:] getMemoryView(self):
        if self.length > 0:
            return <TYPE[:self.length]>self.data
        else:
            # hack to make zero-length memview possible
            return (<TYPE[:1]>self.data)[1:]


    # Classmethods for List Creation
    ###############################################

    @classmethod
    def join(cls, *sourceLists):
        cdef long newLength = 0
        cdef long offset = 0
        cdef LISTNAME source

        for source in sourceLists:
            newLength += len(source)
        newList = LISTNAME(newLength)
        for source in sourceLists:
            newList.overwrite(source, offset)
            offset += source.length

        return newList

    @classmethod
    def fromValues(cls, values):
        if isinstance(values, (list, tuple)):
            return cls.fromListOrTuple(values)

        try: return toLISTNAME(values)
        except TypeError: pass

        cdef LISTNAME newList = LISTNAME()
        newList.extend(values)
        return newList

    @classmethod
    def fromListOrTuple(cls, list_or_tuple values):
        newList = LISTNAME(len(values))
        cdef long i
        for i, value in enumerate(values):
            newList.data[i] = value
        return newList


    # String Representations
    ###############################################

    def __repr__(self):
        memView = self.getMemoryView()
        if len(memView) < 20:
            return "<LISTNAME {}>".format(list(memView))
        else:
            return "<LISTNAME [{}, ...]>".format(", ".join(str(e) for e in memView[:20]))

    def status(self):
        return "Length: {}, Capacity: {}, Size: {} bytes".format(
            self.length, self.capacity, self.capacity * sizeof(TYPE))


cdef class LISTNAMEIterator:
    '''
    Implements the 'Iterator Protocol' that is used to allow iteration
    over a custom list object (eg with a for loop).
    An instance of this class is only created in the __iter__ method
    of the corresponding list type.
    https://docs.python.org/3.5/library/stdtypes.html#iterator-types
    '''
    cdef:
        LISTNAME source
        long current

    def __cinit__(self, LISTNAME source):
        self.source = source
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.source.length:
            raise StopIteration()
        cdef TYPE currentValue = self.source.data[self.current]
        self.current += 1
        return currentValue
