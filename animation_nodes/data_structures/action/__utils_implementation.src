
# Fill
#######################################################

cdef class FilledBOUNDTYPEActionEvaluator(BOUNDTYPEActionEvaluator):
    cdef:
        FloatList evaluatorTarget
        FloatList defaults
        IntegerList defaultMapping
        IntegerList evaluatorMapping
        BOUNDTYPEActionEvaluator evaluator

    def __cinit__(self, BOUNDTYPEAction source, list channels, FloatList defaults):
        self.channelAmount = len(channels)

        cdef list evaluatorChannels = []
        self.defaultMapping = IntegerList()
        self.evaluatorMapping = IntegerList()

        cdef Py_ssize_t i, j
        for i, channel in enumerate(channels):
            if channel in source.channels:
                evaluatorChannels.append(channel)
                self.evaluatorMapping.append(i)
            else:
                self.defaultMapping.append(i)

        self.defaults = defaults
        self.evaluator = source.getEvaluator(evaluatorChannels)
        self.evaluatorTarget = FloatList(length = len(evaluatorChannels))

    cdef void evaluate(self, float frame, Py_ssize_t index, float *target):
        self.evaluator.evaluate(frame, index, self.evaluatorTarget.data)

        cdef Py_ssize_t i
        for i in range(self.evaluatorMapping.length):
            target[self.evaluatorMapping.data[i]] = self.evaluatorTarget.data[i]

        cdef Py_ssize_t j
        for i in range(self.defaultMapping.length):
            j = self.defaultMapping.data[i]
            target[j] = self.defaults.data[j]

#IF "BOUNDTYPE" == "Bounded"
    cpdef float getStart(self, Py_ssize_t index):
        return self.evaluator.getStart(index)

    cpdef float getEnd(self, Py_ssize_t index):
        return self.evaluator.getEnd(index)

    cpdef float getLength(self, Py_ssize_t index):
        return self.evaluator.getLength(index)
#ENDIF



# Remap
##################################################

cdef class RemapBOUNDTYPEActionEvaluator(BoundedActionEvaluator):
    cdef BOUNDTYPEActionEvaluator evaluator
    cdef IntegerList mapping
    cdef FloatList target

    def __cinit__(self, BOUNDTYPEActionEvaluator evaluator,
                        list evaluatedChannels, list requiredChannels):
        self.evaluator = evaluator
        self.channelAmount = len(requiredChannels)
        self.mapping = IntegerList(length = self.channelAmount)
        self.target = FloatList(length = len(evaluatedChannels))

        cdef Py_ssize_t i
        for i in range(self.channelAmount):
            self.mapping.data[i] = evaluatedChannels.index(requiredChannels[i])

    cdef void evaluate(self, float frame, Py_ssize_t index, float *target):
        self.evaluator.evaluate(frame, index, self.target.data)

        cdef Py_ssize_t i
        for i in range(self.channelAmount):
            target[i] = self.target.data[self.mapping.data[i]]

#IF "BOUNDTYPE" == "Bounded"
    cpdef float getStart(self, Py_ssize_t index):
        return self.evaluator.getStart(index)

    cpdef float getEnd(self, Py_ssize_t index):
        return self.evaluator.getEnd(index)

    cpdef float getLength(self, Py_ssize_t index):
        return self.evaluator.getLength(index)
#ENDIF


# Custom
###########################################################

cdef class CustomBOUNDTYPEAction(BOUNDTYPEAction):
    cdef list getEvaluateFunctions(self):
        raise NotImplementedError()

    cdef newFunction(self, void *function, list channels):
        cdef EvaluateFunctionData data = EvaluateFunctionData()
        data.function = <EvaluateFunction>function
        data.channels = channels
        return data

#IF "BOUNDTYPE" == "Bounded"
    cdef float getStart(self, Py_ssize_t index):
        raise NotImplementedError()

    cdef float getEnd(self, Py_ssize_t index):
        raise NotImplementedError()

    cdef float getLength(self, Py_ssize_t index):
        raise NotImplementedError()
#ENDIF

    cdef BOUNDTYPEActionEvaluator getEvaluator_Limited(self, list channels):
        return BOUNDTYPECustomActionEvaluator(self, channels)

cdef class BOUNDTYPECustomActionEvaluator(BOUNDTYPEActionEvaluator):

    def __cinit__(self, CustomBOUNDTYPEAction action, list channels):
        cdef list requiredFunctions = []
        cdef set requiredChannels = set(channels)
        cdef list targetChannels = []
        cdef EvaluateFunctionData data

        for data in action.getEvaluateFunctions():
            if not requiredChannels.isdisjoint(data.channels):
                requiredFunctions.append(data)
                targetChannels.extend(data.channels)
        self.channelAmount = len(channels)

        cdef Py_ssize_t i
        self.functions = <EvaluateFunction*>PyMem_Malloc(sizeof(EvaluateFunction) * len(requiredFunctions))
        for i in range(len(requiredFunctions)):
            self.functions[i] = (<EvaluateFunctionData>requiredFunctions[i]).function

        self.channelAmounts = IntegerList.fromValues([len(data.channels) for data in requiredFunctions])

        self.mapping = IntegerList(length = self.channelAmount)
        for i in range(self.channelAmount):
            self.mapping.data[i] = targetChannels.index(channels[i])

        self.target = FloatList(length = len(targetChannels))
        self.action = action

    def __dealloc__(self):
        PyMem_Free(self.functions)

    cdef void evaluate(self, float frame, Py_ssize_t index, float *target):
        cdef Py_ssize_t i
        cdef Py_ssize_t pos = 0
        for i in range(self.channelAmounts.length):
            self.functions[i](<void*>self.action, frame, index, self.target.data + pos)
            pos += self.channelAmounts.data[i]

        for i in range(self.channelAmount):
            target[i] = self.target.data[self.mapping.data[i]]

#IF "BOUNDTYPE" == "Bounded"
    cpdef float getStart(self, Py_ssize_t index):
        return self.action.getStart(index)

    cpdef float getEnd(self, Py_ssize_t index):
        return self.action.getEnd(index)

    cpdef float getLength(self, Py_ssize_t index):
        return self.action.getLength(index)
#ENDIF
